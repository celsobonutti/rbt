// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc-bindgen` CLI

#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]

#[cfg(any(
    target_arch = "x86_64",
    target_arch = "x86",
    target_arch = "aarch64",
    target_arch = "arm",
    target_arch = "wasm32"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Rbt(pub Job);

#[cfg(any(
    target_arch = "x86_64",
    target_arch = "x86",
    target_arch = "aarch64",
    target_arch = "arm",
    target_arch = "wasm32"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Job(pub R1);

#[cfg(any(
    target_arch = "x86_64",
    target_arch = "x86",
    target_arch = "aarch64",
    target_arch = "arm",
    target_arch = "wasm32"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R1 {
    pub command: Command,
    pub inputFiles: roc_std::RocList<roc_std::RocStr>,
}

#[cfg(any(
    target_arch = "x86_64",
    target_arch = "x86",
    target_arch = "aarch64",
    target_arch = "arm",
    target_arch = "wasm32"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Command(pub R2);

#[cfg(any(
    target_arch = "x86_64",
    target_arch = "x86",
    target_arch = "aarch64",
    target_arch = "arm",
    target_arch = "wasm32"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct R2(pub Tool);

#[cfg(any(
    target_arch = "x86_64",
    target_arch = "x86",
    target_arch = "aarch64",
    target_arch = "arm",
    target_arch = "wasm32"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct R4(pub roc_std::RocStr);

#[cfg(any(
    target_arch = "x86_64",
    target_arch = "x86",
    target_arch = "aarch64",
    target_arch = "arm",
    target_arch = "wasm32"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct R3(pub roc_std::RocStr);

#[cfg(any(
    target_arch = "x86_64",
    target_arch = "x86",
    target_arch = "aarch64",
    target_arch = "arm",
    target_arch = "wasm32"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum variant_Tool {
    FromJob = 0,
    SystemTool = 1,
}

impl core::fmt::Debug for variant_Tool {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::FromJob => f.write_str("variant_Tool::FromJob"),
            Self::SystemTool => f.write_str("variant_Tool::SystemTool"),
        }
    }
}

#[cfg(any(
    target_arch = "x86_64",
    target_arch = "aarch64"
))]
#[repr(C)]
pub union Tool {
    FromJob: core::mem::ManuallyDrop<R3>,
    SystemTool: core::mem::ManuallyDrop<R4>,
    _sizer: [u8; 56],
}

#[cfg(any(
    target_arch = "x86",
    target_arch = "arm",
    target_arch = "wasm32"
))]
#[repr(C)]
pub union Tool {
    FromJob: core::mem::ManuallyDrop<R3>,
    SystemTool: core::mem::ManuallyDrop<R4>,
    _sizer: [u8; 28],
}

impl Tool {
    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "aarch64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn variant(&self) -> variant_Tool {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, variant_Tool>(*bytes.as_ptr().add(24))
        }
    }

    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "aarch64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: variant_Tool) {
        let discriminant_ptr: *mut variant_Tool = (self as *mut Tool).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    /// Construct a tag named FromJob, with the appropriate payload
    pub fn FromJob(arg: roc_std::RocStr) -> Self {
        let size = core::mem::size_of::<union_Tool>();
        let align = core::mem::size_of::<union_Tool>() as u32;

        unsafe {
            let ptr = crate::roc_alloc(size, align) as *mut union_Tool;

            *ptr = union_Tool {
                FromJob: core::mem::ManuallyDrop::new(R3(arg))
            };

            Self {
                pointer: Self::tag_discriminant(ptr, variant_Tool::FromJob),
            }
        }
    }

    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    /// Unsafely assume the given Tool has a .variant() of FromJob and convert it to FromJob's payload.
    /// (Always examine .variant() first to make sure this is the correct variant!)
    /// Panics in debug builds if the .variant() doesn't return FromJob.
    pub unsafe fn into_FromJob(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.variant(), variant_Tool::FromJob);

        let payload = unsafe {
            let ptr = (self.pointer as usize & !) as *mut union_Tool;

            core::mem::ManuallyDrop::take(&mut (*ptr).FromJob)
        };

        payload.0
    }

    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    /// Unsafely assume the given Tool has a .variant() of FromJob and return its payload.
    /// (Always examine .variant() first to make sure this is the correct variant!)
    /// Panics in debug builds if the .variant() doesn't return FromJob.
    pub unsafe fn as_FromJob(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.variant(), variant_Tool::FromJob);

        let payload = unsafe {
            let ptr = (self.pointer as usize & !) as *mut union_Tool;

            &(*ptr).FromJob
        };

        &payload.0
    }

    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    /// Construct a tag named SystemTool, with the appropriate payload
    pub fn SystemTool(arg: roc_std::RocStr) -> Self {
        let size = core::mem::size_of::<union_Tool>();
        let align = core::mem::size_of::<union_Tool>() as u32;

        unsafe {
            let ptr = crate::roc_alloc(size, align) as *mut union_Tool;

            *ptr = union_Tool {
                SystemTool: core::mem::ManuallyDrop::new(R4(arg))
            };

            Self {
                pointer: Self::tag_discriminant(ptr, variant_Tool::SystemTool),
            }
        }
    }

    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    /// Unsafely assume the given Tool has a .variant() of SystemTool and convert it to SystemTool's payload.
    /// (Always examine .variant() first to make sure this is the correct variant!)
    /// Panics in debug builds if the .variant() doesn't return SystemTool.
    pub unsafe fn into_SystemTool(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.variant(), variant_Tool::SystemTool);

        let payload = unsafe {
            let ptr = (self.pointer as usize & !) as *mut union_Tool;

            core::mem::ManuallyDrop::take(&mut (*ptr).SystemTool)
        };

        payload.0
    }

    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    /// Unsafely assume the given Tool has a .variant() of SystemTool and return its payload.
    /// (Always examine .variant() first to make sure this is the correct variant!)
    /// Panics in debug builds if the .variant() doesn't return SystemTool.
    pub unsafe fn as_SystemTool(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.variant(), variant_Tool::SystemTool);

        let payload = unsafe {
            let ptr = (self.pointer as usize & !) as *mut union_Tool;

            &(*ptr).SystemTool
        };

        &payload.0
    }

    #[cfg(any(
        target_arch = "x86",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn variant(&self) -> variant_Tool {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, variant_Tool>(*bytes.as_ptr().add(12))
        }
    }

    #[cfg(any(
        target_arch = "x86",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: variant_Tool) {
        let discriminant_ptr: *mut variant_Tool = (self as *mut Tool).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }
}

impl Drop for Tool {
    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    fn drop(&mut self) {
        match self.variant() {
            variant_Tool::FromJob => unsafe { core::mem::ManuallyDrop::drop(&mut self.FromJob) },
            variant_Tool::SystemTool => unsafe { core::mem::ManuallyDrop::drop(&mut self.SystemTool) },
        }
    }
}

impl Eq for Tool {}

impl PartialEq for Tool {
    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.variant() != other.variant() {
                return false;
            }

            unsafe {
            match self.variant() {
                variant_Tool::FromJob => self.FromJob == other.FromJob,
                variant_Tool::SystemTool => self.SystemTool == other.SystemTool,
            }
        }
    }
}

impl PartialOrd for Tool {
    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.variant().partial_cmp(&other.variant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.variant() {
                variant_Tool::FromJob => self.FromJob.partial_cmp(&other.FromJob),
                variant_Tool::SystemTool => self.SystemTool.partial_cmp(&other.SystemTool),
            }
        }
    }
}

impl Ord for Tool {
    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.variant().cmp(&other.variant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.variant() {
                variant_Tool::FromJob => self.FromJob.cmp(&other.FromJob),
                variant_Tool::SystemTool => self.SystemTool.cmp(&other.SystemTool),
            }
        }
    }
}

impl Clone for Tool {
    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.variant() {
                variant_Tool::FromJob => Self {
                    FromJob: self.FromJob.clone(),
                },
                variant_Tool::SystemTool => Self {
                    SystemTool: self.SystemTool.clone(),
                },
            }

        };

        answer.set_discriminant(self.variant());

        answer
    }
}

impl core::hash::Hash for Tool {
    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.variant() {
            variant_Tool::FromJob => unsafe {
                    variant_Tool::FromJob.hash(state);
                    self.FromJob.hash(state);
                },
            variant_Tool::SystemTool => unsafe {
                    variant_Tool::SystemTool.hash(state);
                    self.SystemTool.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for Tool {
    #[cfg(any(
        target_arch = "x86_64",
        target_arch = "x86",
        target_arch = "aarch64",
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.write_str("Tool::")?;

            unsafe {
            match self.variant() {
                variant_Tool::FromJob => f.debug_tuple("FromJob").field(&*self.FromJob).finish(),
                variant_Tool::SystemTool => f.debug_tuple("SystemTool").field(&*self.SystemTool).finish(),
            }
        }
    }
}
