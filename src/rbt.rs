use crate::glue;
use itertools::Itertools;
use roc_std::{RocList, RocStr};
use serde::de::Visitor;
use serde::ser::SerializeSeq;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::hash::{Hash, Hasher};

#[derive(Debug, Serialize, Deserialize)]
pub struct Rbt {
    pub default: Job,
}

impl From<glue::Rbt> for Rbt {
    fn from(rbt: glue::Rbt) -> Self {
        let unwrapped = rbt.f0;

        Rbt {
            default: Job::from(unwrapped.default),
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Job {
    pub command: Command,
    pub inputs: HashMap<String, Job>, // TODO: when this can be generated by glue it will need to be a RocList
    #[serde(
        serialize_with = "serialize_roc_list_of_roc_str",
        deserialize_with = "deserialize_roc_list_of_roc_str"
    )]
    pub input_files: RocList<RocStr>,
    #[serde(
        serialize_with = "serialize_roc_list_of_roc_str",
        deserialize_with = "deserialize_roc_list_of_roc_str"
    )]
    pub outputs: RocList<RocStr>,
}

impl From<glue::Job> for Job {
    fn from(job: glue::Job) -> Self {
        // let unwrapped = job.into_Job();
        let unwrapped = job.f0;

        Job {
            command: Command::from(unwrapped.command),
            inputs: HashMap::default(),
            input_files: unwrapped.inputFiles,
            outputs: unwrapped.outputs,
        }
    }
}

// TODO: when Job has Eq, it must be true that `j1 == j2 => hash(j1) == hash(j2)`
impl Hash for Job {
    /// `Job` is hashed specifically to be able to track dependencies. That means
    /// that the hash has to be stable with respect to the ordering of the inputs
    /// in the HashMap, regardless of the hashing function it uses! It should
    /// also be stable across runs. This custom implementation is a little more
    /// expensive than just iterating over the keys in the order they appear,
    /// but gives us the stability we need for further calculations.
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.command.hash(state);
        self.input_files.hash(state);
        self.outputs.hash(state);

        for (name, input) in self.inputs.iter().sorted_by(|a, b| Ord::cmp(&a.0, &b.0)) {
            name.hash(state);
            input.hash(state);
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Hash)]
pub struct Command {
    pub tool: Tool,
    #[serde(
        serialize_with = "serialize_roc_list_of_roc_str",
        deserialize_with = "deserialize_roc_list_of_roc_str"
    )]
    pub args: RocList<RocStr>,
}

impl From<glue::Command> for Command {
    fn from(command: glue::Command) -> Self {
        // let unwrapped = command.into_Job();
        let unwrapped = command.f0;

        Command {
            tool: Tool::from(unwrapped.tool),
            args: unwrapped.args,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Hash)]
pub enum Tool {
    SystemTool {
        #[serde(
            serialize_with = "serialize_roc_str",
            deserialize_with = "deserialize_roc_str"
        )]
        name: RocStr,
    },
}

impl From<glue::Tool> for Tool {
    fn from(tool: glue::Tool) -> Self {
        Self::SystemTool { name: tool.f0 }
    }
}

// Remote Types
//// RocList<RocStr>

fn serialize_roc_list_of_roc_str<S>(
    list: &RocList<RocStr>,
    serializer: S,
) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    let mut seq = serializer.serialize_seq(Some(list.len()))?;
    for item in list {
        seq.serialize_element(item.as_str())?;
    }
    seq.end()
}

fn deserialize_roc_list_of_roc_str<'de, D>(deserializer: D) -> Result<RocList<RocStr>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    deserializer.deserialize_seq(RocListOfRocStringVisitor {})
}

struct RocListOfRocStringVisitor {}

impl<'de> Visitor<'de> for RocListOfRocStringVisitor {
    type Value = RocList<RocStr>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(formatter, "a list of strings")
    }

    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::SeqAccess<'de>,
    {
        let mut out: Vec<RocStr> = match seq.size_hint() {
            Some(hint) => Vec::with_capacity(hint),
            None => Vec::new(),
        };

        while let Some(next) = seq.next_element::<String>()? {
            out.push(RocStr::from(next.as_str()))
        }

        Ok(RocList::from_slice(&out))
    }
}

//// RocStr

fn serialize_roc_str<S>(roc_str: &RocStr, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    serializer.serialize_str(roc_str.as_str())
}

fn deserialize_roc_str<'de, D>(deserializer: D) -> Result<RocStr, D::Error>
where
    D: serde::Deserializer<'de>,
{
    deserializer.deserialize_string(RocStringVisitor {})
}

struct RocStringVisitor {}

impl<'de> Visitor<'de> for RocStringVisitor {
    type Value = RocStr;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(formatter, "a string")
    }

    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        Ok(RocStr::from(value))
    }
}
